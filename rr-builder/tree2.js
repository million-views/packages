// Import the Node.js file system module
import fs from "node:fs";
import path from "node:path"; // Using path module for joining segments

// --- Get input file path and options from command-line arguments ---
// process.argv is an array containing the command-line arguments.
// process.argv[0] is the path to the node executable.
// process.argv[1] is the path to the script file being executed.
// process.argv[2] is expected to be the path to the JSON file.
// Subsequent arguments are options (like --details).
const inputJsonFilePath = process.argv[2];
const showDetails = process.argv.includes("--details"); // Check for the --details flag

// --- Check if a file path argument was provided ---
if (!inputJsonFilePath) {
  console.error(
    "Usage: node your_script_name.js <path_to_json_file> [--details]",
  );
  process.exit(1); // Exit the process with an error code
}

/**
 * Converts a string to PascalCase.
 * @param {string} str - The input string.
 * @returns {string} The string in PascalCase.
 */
function toPascalCase(str) {
  if (!str) return "";
  return str
    .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : "")) // Remove hyphens/underscores and capitalize next char
    .replace(/^(.)/, (_, c) => c.toUpperCase()); // Capitalize the first character
}

/**
 * Parses the nested JSON data and builds a flat map of nodes keyed by their path.
 * This helps in quickly accessing parent nodes when building the tree structure.
 * @param {object[]} jsonData - The array of JSON objects from the input file.
 * @returns {object} A map where keys are paths and values are the original JSON objects.
 */
function flattenJsonData(jsonData) {
  const nodeMap = {};

  /**
   * Recursively traverses the JSON structure and adds nodes to the map.
   * @param {object[]} nodes - An array of nodes from the JSON structure (top level or children array).
   */
  function traverse(nodes) {
    if (!Array.isArray(nodes)) {
      // Handle cases where 'children' might not be an array or is missing
      return;
    }
    nodes.forEach((node) => {
      if (node && node.path !== undefined) { // Ensure node is not null/undefined and has a path
        nodeMap[node.path] = node;
      }
      if (node && node.children && Array.isArray(node.children)) {
        traverse(node.children);
      }
    });
  }

  traverse(jsonData);
  return nodeMap;
}

/**
 * Builds a hierarchical tree structure from the flattened JSON data.
 * The structure is an object with 'name', 'label', 'children', and optionally 'originalJson' properties.
 * Intermediate nodes will get a derived label (PascalCase of their name) unless
 * a specific label is provided in the original JSON data for that path,
 * in which case the provided label overrides the derived one.
 * The 'originalJson' property is added to nodes that directly correspond to an entry in the input JSON.
 * @param {object} nodeMap - A map of JSON nodes keyed by their path, generated by flattenJsonData.
 * @returns {object} The root node of the tree structure.
 */
function buildTree(nodeMap) {
  // Initialize the root node. The root path '/' is handled explicitly.
  const root = { name: "/", label: "", children: {} };
  const internalNodes = { "/": root }; // Use a map for quick access to internal nodes by path

  // Get all paths from the node map and sort them to ensure parents are processed before children
  const sortedPaths = Object.keys(nodeMap).sort();

  sortedPaths.forEach((path) => {
    const jsonItem = nodeMap[path];
    // Get label from handle, checking if handle and label exist
    const explicitLabel =
      (jsonItem.handle && jsonItem.handle.label !== undefined)
        ? `[${jsonItem.handle.label}]`
        : undefined;

    // Handle the root path separately
    if (path === "/") {
      root.label = explicitLabel !== undefined
        ? explicitLabel
        : `[${toPascalCase(root.name)}]`;
      root.originalJson = jsonItem; // Store reference to original JSON item for the root
      internalNodes["/"] = root; // Ensure root is in the map with its label
      return; // Skip further processing for the root path
    }

    // Split the path into segments, filtering out empty strings
    const segments = path.split("/").filter((segment) => segment !== "");

    let currentNode = root;
    let currentPath = ""; // To build the path string for the internalNodes map

    // Traverse or create internal nodes for each segment
    segments.forEach((segment, index) => {
      // Build the path for the current segment
      currentPath = (currentPath === "/" ? "" : currentPath) + "/" + segment;
      if (currentPath === "") currentPath = "/"; // Handle case for the first segment relative to root

      // If the segment doesn't exist as a child of the current node, create it
      if (!currentNode.children[segment]) {
        currentNode.children[segment] = {
          name: segment,
          // Assign a derived label when the node is first created
          label: `[${toPascalCase(segment)}]`,
          children: {},
        };
        // Add the newly created internal node to the internalNodes map
        internalNodes[currentPath] = currentNode.children[segment];
      }

      // Move to the next internal node
      currentNode = internalNodes[currentPath]; // Use the node from the map to ensure correct reference

      // If this is the last segment of the original path:
      if (index === segments.length - 1) {
        // Assign the explicit label if provided, otherwise keep the derived one
        if (explicitLabel !== undefined) {
          currentNode.label = explicitLabel;
        }
        // Store a reference to the original JSON item on this internal node
        currentNode.originalJson = jsonItem;
        // Ensure the final internal node in the map has the correct label and originalJson reference
        internalNodes[path] = currentNode;
      }
    });
  });

  return root;
}

/**
 * Recursively generates the tree string representation.
 * @param {object} node - The current node being processed.
 * @param {string} prefix - The prefix string for the current level (indentation and connectors).
 * @param {boolean} isLast - True if the current node is the last sibling.
 * @param {boolean} showDetails - Whether to print additional details (id, path, index) from the original JSON.
 * @returns {string} The tree string representation for the current node and its children.
 */
function generateTreeString(
  node,
  prefix = "",
  isLast = true,
  showDetails = false,
) {
  // Determine the connector and indentation
  const connector = isLast ? "└── " : "├── ";
  // The indentation for children depends on whether the current node was the last sibling
  const indentation = prefix + (isLast ? "    " : "│   ");

  // Format the current node's basic line (name and label)
  let nodeLine = "";
  // Special case for the very first root node line
  if (node.name === "/" && prefix === "") {
    nodeLine = `/ ${node.label}`;
  } else if (node.name !== undefined && node.name !== "") { // Avoid printing lines for purely structural nodes without a name
    nodeLine = `${prefix}${connector}${node.name} ${node.label}`;
  } else if (node.label !== undefined && node.label !== "") { // If no name but has a label, print the label
    nodeLine = `${prefix}${connector}${node.label}`;
  }

  // Add details (id, path, index) if showDetails is true and originalJson is available
  if (showDetails && node.originalJson) {
    const details = [];
    if (node.originalJson.id !== undefined) {
      details.push(`id: ${node.originalJson.id}`);
    }
    if (node.originalJson.path !== undefined) {
      details.push(`path: ${node.originalJson.path}`);
    }
    // Add index detail ONLY if originalJson.index is strictly true
    if (node.originalJson.index === true) {
      details.push("index: true");
    }

    if (details.length > 0) {
      nodeLine += ` (${details.join(", ")})`;
    }
  }

  // Add newline character if a line was generated
  if (nodeLine !== "") {
    nodeLine += "\n";
  }

  let result = nodeLine;

  // Get children keys and sort them alphabetically for consistent output
  const childrenKeys = Object.keys(node.children).sort();
  const numChildren = childrenKeys.length;

  // Recursively process children
  childrenKeys.forEach((key, index) => {
    const childNode = node.children[key];
    const isLastChild = index === numChildren - 1;
    // Recursively call for children, updating the prefix and passing the showDetails flag
    const nextPrefix = (node.name === "/" && prefix === "") ? "" : indentation;
    result += generateTreeString(
      childNode,
      nextPrefix,
      isLastChild,
      showDetails,
    );
  });

  return result;
}

// --- Main execution ---

try {
  // Read the JSON file synchronously using the path from command-line arguments
  const jsonData = JSON.parse(fs.readFileSync(inputJsonFilePath, "utf8"));

  // Flatten the nested JSON structure into a map for easier processing
  const nodeMap = flattenJsonData(jsonData);

  // Build the hierarchical tree structure from the flattened data
  const treeStructure = buildTree(nodeMap);

  // Generate the final tree output string
  // We need to handle the root node's initial line separately for the desired output format
  // Pass the showDetails flag to the initial call
  let treeOutput = `/ ${treeStructure.label}`;
  // Add details for the root if requested and available
  if (showDetails && treeStructure.originalJson) {
    const details = [];
    if (treeStructure.originalJson.id !== undefined) {
      details.push(`id: ${treeStructure.originalJson.id}`);
    }
    if (treeStructure.originalJson.path !== undefined) {
      details.push(`path: ${treeStructure.originalJson.path}`);
    }
    // Add index detail ONLY if originalJson.index is strictly true for the root
    if (treeStructure.originalJson.index === true) {
      details.push("index: true");
    }
    if (details.length > 0) {
      treeOutput += ` (${details.join(", ")})`;
    }
  }
  treeOutput += "\n";

  // Generate the string for the children of the root node
  const rootChildrenKeys = Object.keys(treeStructure.children).sort();
  const numRootChildren = rootChildrenKeys.length;

  rootChildrenKeys.forEach((key, index) => {
    const childNode = treeStructure.children[key];
    const isLastChild = index === numRootChildren - 1;
    // Start the recursive generation from the root's children, with an empty initial prefix
    // Pass the showDetails flag to the recursive calls
    treeOutput += generateTreeString(childNode, "", isLastChild, showDetails);
  });

  // Output the result to the console
  console.log(treeOutput);
} catch (error) {
  // Provide more specific error messages
  if (error.code === "ENOENT") {
    console.error(`Error: File not found at "${inputJsonFilePath}"`);
  } else if (error instanceof SyntaxError) {
    console.error(
      `Error parsing JSON file "${inputJsonFilePath}":`,
      error.message,
    );
  } else {
    console.error(
      `An unexpected error occurred while processing "${inputJsonFilePath}":`,
      error,
    );
  }
  process.exit(1); // Exit with an error code on failure
}

// To run this code:
// 1. Save this code as a .js file (e.g., tree.js).
// 2. Save your JSON data into a file (e.g., tree.json).
// 3. Make sure you have Node.js installed.
// 4. Run the script from your terminal, providing the path to your JSON file as the first argument.
//    To show details (id, path, and index if true), add the --details flag:
//    node tree.js path/to/your/input.json --details
//    To hide details (default behavior):
//    node tree.js path/to/your/input.json
